{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nThe CodeLingo platform guide's software teams to build better code, faster. CodeLingo has been built to integrate with the unique workflows and existing tooling of software development teams and their unique software development life-cycle (SDLC). With CodeLingo you can query patterns in any domain of the SDLC and automate tasks based on the patterns found. From static to runtime analysis, to timelines and logs - powerful \nFlows\n can be written to: automate code reviews, provide real-time crash reporting, performance tune systems, migrate architectures and so on.\n\n\nOur Enterprise offering includes access to the CodeLingo team to compose solutions for customers based on their unique software development life-cycle (SDLC) and to on-board the customer so they can compose/develop their own solutions.", 
            "title": "Overview"
        }, 
        {
            "location": "/#overview", 
            "text": "The CodeLingo platform guide's software teams to build better code, faster. CodeLingo has been built to integrate with the unique workflows and existing tooling of software development teams and their unique software development life-cycle (SDLC). With CodeLingo you can query patterns in any domain of the SDLC and automate tasks based on the patterns found. From static to runtime analysis, to timelines and logs - powerful  Flows  can be written to: automate code reviews, provide real-time crash reporting, performance tune systems, migrate architectures and so on.  Our Enterprise offering includes access to the CodeLingo team to compose solutions for customers based on their unique software development life-cycle (SDLC) and to on-board the customer so they can compose/develop their own solutions.", 
            "title": "Overview"
        }, 
        {
            "location": "/tutorials/getting-started/", 
            "text": "Getting Started with the lingo Client\n\n\nThe lingo client is a command line interface (CLI) tool used to manage the \nLexicons\n, \nTenets\n and \nBots\n. The lingo client will help you find, create and run these resources.\n\n\n\n\nInstall\n\n\nDownload\n a pre-built binary or, if you have \nGolang setup\n, install from source:\n\n\n$ git clone https://github.com/codelingo/lingo $GOPATH/src/github.com/codelingo/lingo\n$ cd $GOPATH/src/github.com/codelingo/lingo\n$ make install\n\n\n\n\nThis will download, build and place the \nlingo\n binary on your $PATH\n\n\n\n\nWindows\n\n\nPut the binary in a folder listed in your %PATH%. If you don't have an appropriate folder set up, create a new one (ie C:\\Lingo) and append it to PATH with a ; in between by going to Control Panel\\System and Security\\System -\n Advanced system settings -\n Environment Variables\n\n\n\n\nLinux / Unix\n\n\nPlace the lingo binary on your $PATH.\n\n\n\n\nSetup\n\n\n\n\n\n\nCreate a CodeLingo account: \nhttp://codelingo.io/join\n\n\n\n\n\n\nSetup lingo with your user account:\n\n\n\n\n\n\n$ lingo setup\n\n\n\n\nYou will be prompted to enter a username and token. You can generate the token at codelingo.io/lingo-token. That's it. The lingo tool is now setup on your computer.\n\n\n\n\nUnder The Hood\n: The setup command creates a ~/.codelingo folder in which it stores credentials and configuration details to push code up and get issues back from the CodeLingo platform. You'll note it also adds a ~/.codelingo/config/git-credentials file. This is used by the lingo tool, via git, to sync code to the CodeLingo git server.\n\n\n\n\nRun a Review\n\n\n\n\n\nCodeLingo's flagship Bot is CLAIR, CodeLingo AI Reviewer. CLAIR uses Tenets to automatically review pull requests. With the \nlingo\n tool CLAIR can be run on a local repository from the command line. \n CLAIR reads Tenets from .lingo files that live alongside the source code files. The \nlingo new\n command writes a .lingo file and adds a simple Tenet (which simply finds all functions).\n\n\n\n\nUnder The Hood\n: The first time \nlingo review\n is run on a repository, \nlingo\n will automatically add the Codelingo git server as a remote, so that changes can be synced and analysed on the Codelingo platform.\n\n\n\n\nFirst Run\n\n\nSetup a test repository:\n\n\nmkdir myawesomepkg\ncd myawesomepkg\ngit init\n\n\n\n\nAdd a file, named \u201ctest.php\u201d, with the following source code:\n\n\n?php\nfunction writeMsg() {\n    echo \nHello world!\n;\n}\n\nwriteMsg(); // call the function\n?\n\n\n\n\n\nAdd your first Tenet and save it, unchanged:\n\n\nlingo new\n\n\n\n\nCommit:\n\n\ngit add -A .\ngit commit -m\ninitial commit\n\n\n\n\n\nThen run \nlingo review\n. You should see the following output:\n\n\ntest.php:2\n\n    This is a function, but you probably already knew that.\n\n\n    ...\n\n  \n function writeMsg() {\n        echo \nHello world!\n;\n    }\n\n    ...\n\n[o]pen [d]iscard [K]eep:\n\n\n\n\nAs the Tenet is using the inbuilt common fact \"func\", it will match functions in both PHP and Golang (the two currently supported languages). Add a go file called \"main.go\" with the following source code:\n\n\npackage main\n\nimport (\n  \nfmt\n\n)\n\nfunc main() {\n  fmt.Println(\nHello world\n)\n}\n\n\n\n\nRun \n$ lingo review\n and you should now see two comments - one on the PHP function and the other on the Go function.\n\n\nNote: you don't have to commit this second file. From here on, lingo will be able to see all changes in your repository, whether they are committed or not.\n\n\nTo open a file at the line of the issue, type \no\n and hit return. It will give you an option (which it will remember) to set your editor, defaulting to vi.\n\n\n\n\nWrite a Tenet\n\n\nContinuing on from the first run above, open the .lingo file in your editor of choice and change it to the following:\n\n\ntenets:\n  - bots:\n      codelingo/clair:\n        comments: This is a function, name 'writeMsg', but you probably knew that.\n        name: first-tenet\n    query: |\n      import codelingo/ast/common/0.0.0 as _\n\n      @ clair.comment\n      func:\n        name: \nwriteMsg\n\n\n\n\n\nThis will find funcs named \"writeMsg\". Save and close the file, then run \nlingo review\n. Try adding another func called \"readMsg\" and run a review. Only the \"writeMsg\" func should be highlighted. Now, update the Tenet to find all funcs that end in \"Msg\":\n\n\nquery: |\n  @ clair.comment\n  func:\n    name: /.*Msg$/\n\n\n\n\nCLAIR\n (CodeLingo AI Reviewer). If a query has no \n@ clair.comment\n, then no issue will be raised, even if the pattern is matched.\n\n\nVim has full support for the Lingo syntax, including CLQL. To set it up, \nsee here\n. Other than the match statement, written in CLQL, the rest of a .lingo file is written in YAML. As such, you can set .lingo files to YAML syntax in your IDE to get partial highlighting.\n\n\n\n\n\nDiscovering Lexicons, Tenets and Bots\n\n\nThe CodeLingo Platform supports an eco-system of Lexicons, Tenets and Bots. The lingo client is used to discover them. For example, to list available lexicons run the following:\n\n\n$ lingo lexicon list\n\nast/codelingo/cs\nast/codelingo/php\nast/codelingo/golang\nvcs/codelingo/git\nvcs/codelingo/perforce\n...\n\n\n\n\nTo see a description of a lexicon run  \n$ lingo lexicon describe\n. For example:\n\n\n$ lingo lexicon describe ast/codelingo/cs\n\nC Sharp AST Lexicon\n\nThis lexicon is a list of facts about the C Sharp AST.\n\n\n\n\nTo list all facts the lexicon provides, run \n$ lingo lexicon list-facts ast/codelingo/cs\n. To see the full list of commands available, please run \n$ lingo --help\n. The lingo CLI tool also powers IDE plugins, such as the \nCLQL generation\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/tutorials/getting-started/#getting-started-with-the-lingo-client", 
            "text": "The lingo client is a command line interface (CLI) tool used to manage the  Lexicons ,  Tenets  and  Bots . The lingo client will help you find, create and run these resources.", 
            "title": "Getting Started with the lingo Client"
        }, 
        {
            "location": "/tutorials/getting-started/#install", 
            "text": "Download  a pre-built binary or, if you have  Golang setup , install from source:  $ git clone https://github.com/codelingo/lingo $GOPATH/src/github.com/codelingo/lingo\n$ cd $GOPATH/src/github.com/codelingo/lingo\n$ make install  This will download, build and place the  lingo  binary on your $PATH", 
            "title": "Install"
        }, 
        {
            "location": "/tutorials/getting-started/#windows", 
            "text": "Put the binary in a folder listed in your %PATH%. If you don't have an appropriate folder set up, create a new one (ie C:\\Lingo) and append it to PATH with a ; in between by going to Control Panel\\System and Security\\System -  Advanced system settings -  Environment Variables", 
            "title": "Windows"
        }, 
        {
            "location": "/tutorials/getting-started/#linux-unix", 
            "text": "Place the lingo binary on your $PATH.", 
            "title": "Linux / Unix"
        }, 
        {
            "location": "/tutorials/getting-started/#setup", 
            "text": "Create a CodeLingo account:  http://codelingo.io/join    Setup lingo with your user account:    $ lingo setup  You will be prompted to enter a username and token. You can generate the token at codelingo.io/lingo-token. That's it. The lingo tool is now setup on your computer.   Under The Hood : The setup command creates a ~/.codelingo folder in which it stores credentials and configuration details to push code up and get issues back from the CodeLingo platform. You'll note it also adds a ~/.codelingo/config/git-credentials file. This is used by the lingo tool, via git, to sync code to the CodeLingo git server.", 
            "title": "Setup"
        }, 
        {
            "location": "/tutorials/getting-started/#run-a-review", 
            "text": "CodeLingo's flagship Bot is CLAIR, CodeLingo AI Reviewer. CLAIR uses Tenets to automatically review pull requests. With the  lingo  tool CLAIR can be run on a local repository from the command line.   CLAIR reads Tenets from .lingo files that live alongside the source code files. The  lingo new  command writes a .lingo file and adds a simple Tenet (which simply finds all functions).   Under The Hood : The first time  lingo review  is run on a repository,  lingo  will automatically add the Codelingo git server as a remote, so that changes can be synced and analysed on the Codelingo platform.", 
            "title": "Run a Review"
        }, 
        {
            "location": "/tutorials/getting-started/#first-run", 
            "text": "Setup a test repository:  mkdir myawesomepkg\ncd myawesomepkg\ngit init  Add a file, named \u201ctest.php\u201d, with the following source code:  ?php\nfunction writeMsg() {\n    echo  Hello world! ;\n}\n\nwriteMsg(); // call the function\n?   Add your first Tenet and save it, unchanged:  lingo new  Commit:  git add -A .\ngit commit -m initial commit   Then run  lingo review . You should see the following output:  test.php:2\n\n    This is a function, but you probably already knew that.\n\n\n    ...\n\n    function writeMsg() {\n        echo  Hello world! ;\n    }\n\n    ...\n\n[o]pen [d]iscard [K]eep:  As the Tenet is using the inbuilt common fact \"func\", it will match functions in both PHP and Golang (the two currently supported languages). Add a go file called \"main.go\" with the following source code:  package main\n\nimport (\n   fmt \n)\n\nfunc main() {\n  fmt.Println( Hello world )\n}  Run  $ lingo review  and you should now see two comments - one on the PHP function and the other on the Go function.  Note: you don't have to commit this second file. From here on, lingo will be able to see all changes in your repository, whether they are committed or not.  To open a file at the line of the issue, type  o  and hit return. It will give you an option (which it will remember) to set your editor, defaulting to vi.", 
            "title": "First Run"
        }, 
        {
            "location": "/tutorials/getting-started/#write-a-tenet", 
            "text": "Continuing on from the first run above, open the .lingo file in your editor of choice and change it to the following:  tenets:\n  - bots:\n      codelingo/clair:\n        comments: This is a function, name 'writeMsg', but you probably knew that.\n        name: first-tenet\n    query: |\n      import codelingo/ast/common/0.0.0 as _\n\n      @ clair.comment\n      func:\n        name:  writeMsg   This will find funcs named \"writeMsg\". Save and close the file, then run  lingo review . Try adding another func called \"readMsg\" and run a review. Only the \"writeMsg\" func should be highlighted. Now, update the Tenet to find all funcs that end in \"Msg\":  query: |\n  @ clair.comment\n  func:\n    name: /.*Msg$/  CLAIR  (CodeLingo AI Reviewer). If a query has no  @ clair.comment , then no issue will be raised, even if the pattern is matched.  Vim has full support for the Lingo syntax, including CLQL. To set it up,  see here . Other than the match statement, written in CLQL, the rest of a .lingo file is written in YAML. As such, you can set .lingo files to YAML syntax in your IDE to get partial highlighting.", 
            "title": "Write a Tenet"
        }, 
        {
            "location": "/tutorials/getting-started/#discovering-lexicons-tenets-and-bots", 
            "text": "The CodeLingo Platform supports an eco-system of Lexicons, Tenets and Bots. The lingo client is used to discover them. For example, to list available lexicons run the following:  $ lingo lexicon list\n\nast/codelingo/cs\nast/codelingo/php\nast/codelingo/golang\nvcs/codelingo/git\nvcs/codelingo/perforce\n...  To see a description of a lexicon run   $ lingo lexicon describe . For example:  $ lingo lexicon describe ast/codelingo/cs\n\nC Sharp AST Lexicon\n\nThis lexicon is a list of facts about the C Sharp AST.  To list all facts the lexicon provides, run  $ lingo lexicon list-facts ast/codelingo/cs . To see the full list of commands available, please run  $ lingo --help . The lingo CLI tool also powers IDE plugins, such as the  CLQL generation .", 
            "title": "Discovering Lexicons, Tenets and Bots"
        }, 
        {
            "location": "/tutorials/cs-perforce/", 
            "text": "C# and Perforce\n\n\n\n\nInstall\n\n\nPerforce\n\n\n\n\nDownload the Perforce client (p4) and server (p4d) \nbinaries\n.\n\n\nMake both Perforce binaries executable with \n$ chmod +x \npath to the binary\n and add them to your \n$PATH\n in Linux and Mac or \n%PATH%\n in Windows. \n\n\n\n\nC# lexicon\n\n\nThe CodeLingo Platform comes with the C# lexicon pre-installed.\n\n\n\n\nSetup\n\n\nIf the lingo client has not already been setup, please follow \nthese setup steps\n. \n\n\nNote: The username of the newly created CodeLingo account must be the same as the local Perforce username.\n\n\n\n\nTest Run\n\n\nSetup a test repository:\n\n\nmkdir myawesomepkg\ncd myawesomepkg\np4 -u \np4 username\n init -C0 -n\n\n\n\n\nAdd a file, named \u201ctest.cs\u201d, with the following source code:\n\n\npublic class Hello\n{\n   public static void Main()\n   {\n      System.Console.WriteLine(\nHello, World!\n);\n   }\n}\n\n\n\n\nCreate a new .lingo file:\n\n\nlingo new\n\n\n\n\nEdit the .lingo file as follows:\n\n\nlexicons:\n- codelingo/common\n- codelingo/csharp\ntenets:\n- name: find-funcs\n  doc: Example tenet that finds all functions.\n  comment: This is a function, but you probably already knew that.\n  match: |\n    @ clair.comment\n    csharp.method_declaration({depth: any})\n\n\n\n\nCommit:\n\n\np4 reconcile\np4 submit -d \ninitial submit\n\n\n\n\n\nThen run \nlingo review -i\n. You should see the following output:\n\n\ntest.cs:2\n\n    This is a function, but you probably already knew that.\n\n\n    ...\n\n  \n public static void Main()\n   {\n      System.Console.WriteLine(\nHello, World!\n);\n   }\n\n    ...\n\n[o]pen [d]iscard [K]eep:", 
            "title": "C# and Perforce"
        }, 
        {
            "location": "/tutorials/cs-perforce/#c-and-perforce", 
            "text": "", 
            "title": "C# and Perforce"
        }, 
        {
            "location": "/tutorials/cs-perforce/#install", 
            "text": "", 
            "title": "Install"
        }, 
        {
            "location": "/tutorials/cs-perforce/#perforce", 
            "text": "Download the Perforce client (p4) and server (p4d)  binaries .  Make both Perforce binaries executable with  $ chmod +x  path to the binary  and add them to your  $PATH  in Linux and Mac or  %PATH%  in Windows.", 
            "title": "Perforce"
        }, 
        {
            "location": "/tutorials/cs-perforce/#c-lexicon", 
            "text": "The CodeLingo Platform comes with the C# lexicon pre-installed.", 
            "title": "C# lexicon"
        }, 
        {
            "location": "/tutorials/cs-perforce/#setup", 
            "text": "If the lingo client has not already been setup, please follow  these setup steps .   Note: The username of the newly created CodeLingo account must be the same as the local Perforce username.", 
            "title": "Setup"
        }, 
        {
            "location": "/tutorials/cs-perforce/#test-run", 
            "text": "Setup a test repository:  mkdir myawesomepkg\ncd myawesomepkg\np4 -u  p4 username  init -C0 -n  Add a file, named \u201ctest.cs\u201d, with the following source code:  public class Hello\n{\n   public static void Main()\n   {\n      System.Console.WriteLine( Hello, World! );\n   }\n}  Create a new .lingo file:  lingo new  Edit the .lingo file as follows:  lexicons:\n- codelingo/common\n- codelingo/csharp\ntenets:\n- name: find-funcs\n  doc: Example tenet that finds all functions.\n  comment: This is a function, but you probably already knew that.\n  match: |\n    @ clair.comment\n    csharp.method_declaration({depth: any})  Commit:  p4 reconcile\np4 submit -d  initial submit   Then run  lingo review -i . You should see the following output:  test.cs:2\n\n    This is a function, but you probably already knew that.\n\n\n    ...\n\n    public static void Main()\n   {\n      System.Console.WriteLine( Hello, World! );\n   }\n\n    ...\n\n[o]pen [d]iscard [K]eep:", 
            "title": "Test Run"
        }, 
        {
            "location": "/concepts/search/", 
            "text": "Search\n\n\nFind Patterns Across the SDLC\n\n\n\n\nOverview\n\n\nAt the heart of the CodeLingo Platform is a search engine for the full Software Development Lifecycle (SDLC). Patterns that cross disperse domains can be easily expressed in one query with \nCodeLingo Query Language (CLQL)\n. Below is an example of a query that returns all functions in a repository with more than 4 arguments:\n\n\nlexicons:\n  - codelingo/vcs/git\n  - codelingo/ast/golang as go\n\nmatch:\n  git.repo:\n    owner: \nusername\n\n    host: \nmyvcsgithost.com\n\n    name: \nmyrepo\n\n    git.commit:\n      sha: \nHEAD\n\n      go.project:\n        @ clair.comment\n        go.func_decl:\n          arg_count: \n 4\n\n\n\n\nThe query is made up of two sections: a list of \nLexicons\n and a match statement. Lexicons get data into the CodeLingo Platform and provide a list of facts to query that data. In the above example, the git Lexicon finds and clones the \"myrepo\" repository from the \"myvcsgithost.com\" VCS host. The \"myrepo\" repository must be publicly accessible for the git lexicon to access it.\n\n\nTo access a private repository, the git credentials need to be added to the query:\n\n\n...\nmatch:\n  git.repo:\n    auth:\n      token: \nabctoken\n\n    owner: \nusername\n\n    host: \nmyvcsgithost.com\n\n    name: \nmyrepo\n\n...\n\n\n\n\nThe CodeLingo Platform can be queried directly with the the \n$ lingo search\n command or via \nBots\n which use queries stored in \nTenets\n.", 
            "title": "Search"
        }, 
        {
            "location": "/concepts/search/#search", 
            "text": "", 
            "title": "Search"
        }, 
        {
            "location": "/concepts/search/#find-patterns-across-the-sdlc", 
            "text": "", 
            "title": "Find Patterns Across the SDLC"
        }, 
        {
            "location": "/concepts/search/#overview", 
            "text": "At the heart of the CodeLingo Platform is a search engine for the full Software Development Lifecycle (SDLC). Patterns that cross disperse domains can be easily expressed in one query with  CodeLingo Query Language (CLQL) . Below is an example of a query that returns all functions in a repository with more than 4 arguments:  lexicons:\n  - codelingo/vcs/git\n  - codelingo/ast/golang as go\n\nmatch:\n  git.repo:\n    owner:  username \n    host:  myvcsgithost.com \n    name:  myrepo \n    git.commit:\n      sha:  HEAD \n      go.project:\n        @ clair.comment\n        go.func_decl:\n          arg_count:   4  The query is made up of two sections: a list of  Lexicons  and a match statement. Lexicons get data into the CodeLingo Platform and provide a list of facts to query that data. In the above example, the git Lexicon finds and clones the \"myrepo\" repository from the \"myvcsgithost.com\" VCS host. The \"myrepo\" repository must be publicly accessible for the git lexicon to access it.  To access a private repository, the git credentials need to be added to the query:  ...\nmatch:\n  git.repo:\n    auth:\n      token:  abctoken \n    owner:  username \n    host:  myvcsgithost.com \n    name:  myrepo \n...  The CodeLingo Platform can be queried directly with the the  $ lingo search  command or via  Bots  which use queries stored in  Tenets .", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/tenets/", 
            "text": "Tenets\n\n\nRules to Guide Software Development\n\n\n\n\nOverview\n\n\nA Tenet is a rule about a system written in \nCLQL\n. It is an underlying pattern which the CodeLingo \nBots\n follow to guide development and safeguard systems. Tenets can be added directly to Bots or embedded in the resources they monitor. For example, CLAIR reads .lingo files that live along side source code in a code repository.\n\n\nBelow is an example of a Tenet created from the search query \nexample\n:\n\n\nlexicons:\n  - codelingo/vcs/git\n  - codelingo/ast/golang as go\n\ntenets:\n  - match:\n    git.repo:\n      owner: \nusername\n\n      host: \nmyvcsgithost.com\n\n      name: \nmyrepo\n\n      git.commit:\n        sha: \nHEAD\n\n        go.project:\n          @ clair.comment\n          go.func_decl:\n            arg_count: \n 4\n\n\n\n\nThe minimum requirement for a Tenet is the \nmatch\n statement. Extra metadata can be added to the Tenet to be used by the Bots that apply the Tenet:\n\n\n...\ntenets:\n  - comment: \nPlease keep functions arguments to four or less\n\n    match:\n...\n\n\n\n\nThe \ncomment\n metadata above can be used by a \nBot\n to comment on a pull request review, for example.\n\n\n\n\n\n\n\n\n\n\n\nExamples of Tenets include:\n\n\n\n\nAnything a static linter expresses, with a fraction of the code\n\n\nChange management: large scale incremental refactoring\n\n\nProject specific practices: scaling the tacit knowledge of senior engineers to the whole team\n\n\nInfrastructure specific guidelines / safeguards: learning from failures\n\n\nPackaging the author\u2019s guidance with a library", 
            "title": "Tenets"
        }, 
        {
            "location": "/concepts/tenets/#tenets", 
            "text": "", 
            "title": "Tenets"
        }, 
        {
            "location": "/concepts/tenets/#rules-to-guide-software-development", 
            "text": "", 
            "title": "Rules to Guide Software Development"
        }, 
        {
            "location": "/concepts/tenets/#overview", 
            "text": "A Tenet is a rule about a system written in  CLQL . It is an underlying pattern which the CodeLingo  Bots  follow to guide development and safeguard systems. Tenets can be added directly to Bots or embedded in the resources they monitor. For example, CLAIR reads .lingo files that live along side source code in a code repository.  Below is an example of a Tenet created from the search query  example :  lexicons:\n  - codelingo/vcs/git\n  - codelingo/ast/golang as go\n\ntenets:\n  - match:\n    git.repo:\n      owner:  username \n      host:  myvcsgithost.com \n      name:  myrepo \n      git.commit:\n        sha:  HEAD \n        go.project:\n          @ clair.comment\n          go.func_decl:\n            arg_count:   4  The minimum requirement for a Tenet is the  match  statement. Extra metadata can be added to the Tenet to be used by the Bots that apply the Tenet:  ...\ntenets:\n  - comment:  Please keep functions arguments to four or less \n    match:\n...  The  comment  metadata above can be used by a  Bot  to comment on a pull request review, for example.     Examples of Tenets include:   Anything a static linter expresses, with a fraction of the code  Change management: large scale incremental refactoring  Project specific practices: scaling the tacit knowledge of senior engineers to the whole team  Infrastructure specific guidelines / safeguards: learning from failures  Packaging the author\u2019s guidance with a library", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/lexicons/", 
            "text": "Lexicons\n\n\nLibraries to Query Any Domain\n\n\n\n\nOverview\n\n\nThe SDLC is built up of many different domains. With \nCLQL\n patterns across all these domains are expressed as statements of facts. Those facts come from \nLexicons\n, which are collections of terms about to a domain of knowledge. These domains include:\n\n\n\n\nStatic facts about programming languages (AST): C#, Javascript, Java, PHP, Golang etc\n\n\nDynamic facts about languages (Runtime): values, race conditions, tracing, profiling etc\n\n\nFacts about VCSs: perforce, git, hg, commits, comments, ownership etc\n\n\nFacts about databases, networking, CI, CD, business rules, HR etc\n\n\nFacts about running systems: logs, crash dumps, tracing etc", 
            "title": "Lexicons"
        }, 
        {
            "location": "/concepts/lexicons/#lexicons", 
            "text": "", 
            "title": "Lexicons"
        }, 
        {
            "location": "/concepts/lexicons/#libraries-to-query-any-domain", 
            "text": "", 
            "title": "Libraries to Query Any Domain"
        }, 
        {
            "location": "/concepts/lexicons/#overview", 
            "text": "The SDLC is built up of many different domains. With  CLQL  patterns across all these domains are expressed as statements of facts. Those facts come from  Lexicons , which are collections of terms about to a domain of knowledge. These domains include:   Static facts about programming languages (AST): C#, Javascript, Java, PHP, Golang etc  Dynamic facts about languages (Runtime): values, race conditions, tracing, profiling etc  Facts about VCSs: perforce, git, hg, commits, comments, ownership etc  Facts about databases, networking, CI, CD, business rules, HR etc  Facts about running systems: logs, crash dumps, tracing etc", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/bots/", 
            "text": "Bots\n\n\nAgents Guiding Code Quaity at Scale\n\n\n\n\nOverview\n\n\nBots watch resources and look for patterns in them based on the \nTenets\n associated with the resource. For example, CodeLingo AI Reviewer (CLAIR) is a Bot that preforms a review on a pull request:\n\n\n\n\nCLAIR reads the Tenets written in .lingo files in the repository and queries the platform with them. She can be called directly via the commandline:\n\n\n$ lingo bot clair review --github-pull-request \nhttps://github.com/example/prog/pull/272\n\n\n\n\n\nThis will print out any patterns in the pull request that match those in the Tenets. In addition to being run directly, Bots can be added to a \nFlow\n. When part of a \nFlow\n, Bots process the results and pass them onto an external service or other bots in the Flow.\n\n\nOther possible Bots include:\n\n\n\n\nA forensic Bot that analyses logs and finds event B happened before A, which violates a Tenet\n\n\nA project overview Bot that graphs Tech Debt burndown chart and delegates based on ownership\n\n\nA Copilot Bot that gives real time feedback to a developer in their IDE as they\u2019re coding\n\n\nA profiling Bot that detects high memory usage correlated to similar code\n\n\nA crash report Bot that monitors a running system and reports on unexpected runtime information", 
            "title": "Bots"
        }, 
        {
            "location": "/concepts/bots/#bots", 
            "text": "", 
            "title": "Bots"
        }, 
        {
            "location": "/concepts/bots/#agents-guiding-code-quaity-at-scale", 
            "text": "", 
            "title": "Agents Guiding Code Quaity at Scale"
        }, 
        {
            "location": "/concepts/bots/#overview", 
            "text": "Bots watch resources and look for patterns in them based on the  Tenets  associated with the resource. For example, CodeLingo AI Reviewer (CLAIR) is a Bot that preforms a review on a pull request:   CLAIR reads the Tenets written in .lingo files in the repository and queries the platform with them. She can be called directly via the commandline:  $ lingo bot clair review --github-pull-request  https://github.com/example/prog/pull/272   This will print out any patterns in the pull request that match those in the Tenets. In addition to being run directly, Bots can be added to a  Flow . When part of a  Flow , Bots process the results and pass them onto an external service or other bots in the Flow.  Other possible Bots include:   A forensic Bot that analyses logs and finds event B happened before A, which violates a Tenet  A project overview Bot that graphs Tech Debt burndown chart and delegates based on ownership  A Copilot Bot that gives real time feedback to a developer in their IDE as they\u2019re coding  A profiling Bot that detects high memory usage correlated to similar code  A crash report Bot that monitors a running system and reports on unexpected runtime information", 
            "title": "Overview"
        }, 
        {
            "location": "/concepts/flows/", 
            "text": "Flows\n\n\nYour Systems, Your Way\n\n\n\n\nFlows automate common developer and sysadmin tasks by chaining together a pipeline of \nBots\n. Each Flow has it's own dashboard with panels generated by the Bots in it.\n\n\nFlows can be configured directly in YAML or via the Flow Composer GUI. This allows custom debug dashboards, crash reports, code review UIs and monitoring systems to be composed quickly and easily.\n\n\nBelow are several examples of different Flows.\n\n\nSearch Flow\n\n\nThis Flow builds a simple search dashboard with three panels: a CLQL search field, a list of file and line matches and a graph.\n\n\n\n\nIn this example, the executed query is searching runtime and AST information about a CSharp repository stored in a GitHub repository. To answer the query, the CodeLingo Platform fires up three lexicons: the Git Lexicon retrieves the code from the GitHub repository, the AST lexicon queries the code and the Runtime lexicon builds and runs the code and queries its runtime information.\n\n\nIDE Search Flow\n\n\nInteracting with Flows is not restricted to the Flow Dashboard. Bots can recieve input and give output to other external services.\n\n\n\n\nIn this example a CodeLingo IDE plugin allows the user to query code within their IDE and navigate to the result, while also generating a graph of the results on the Flow Dashboard.\n\n\nReview Flow\n\n\nThis is an example of a fully automated flow with no dashboard. When a pull request is made to the monitored repository, GitHub sends a web hook to the Bot. That Bot then queries the pull request and repository for any Tenets.\n\n\n\n\nThe next Bot in the Flow then queries the pull request with the Tenets. Any issues found are added as comments on the pull request.\n\n\nReview Confirm Flow\n\n\nThis is the same flow as above except a Bot waits for a human to confirm each found issue, via the dashboard, before commenting on the pull request.\n\n\n\n\nFurther customization of this Flow might include categorizing the issues and keeping track of which Tenets where kept and discarded.\n\n\nCrash Report Flow\n\n\nThe crashed program has a single function added to it which sends the stack trace and any other data to the Bot in the Flow. The team is notified via Slack and a crash report is generated, ready to be analysed by a human.\n\n\n\n\nSimilar to the example above, this is a long running Flow which waits to be triggered by an external resource.\n\n\nCrash Redeploy Flow\n\n\nThis Flow extends the above crash report Flow to add in debugging, fixing and preventing. First the crash dump is sent, an issue is added on Jira and the team are alerted on Slack.\n\n\nAlong with the report panels, debug panels are added to help narrow down the cause of the crash and generate a Tenet to protect against future occurrences. The Lexicons reproduce a running state of the software, which matches, as close as possible, that of the crashed program with the information provided.", 
            "title": "Flows"
        }, 
        {
            "location": "/concepts/flows/#flows", 
            "text": "", 
            "title": "Flows"
        }, 
        {
            "location": "/concepts/flows/#your-systems-your-way", 
            "text": "Flows automate common developer and sysadmin tasks by chaining together a pipeline of  Bots . Each Flow has it's own dashboard with panels generated by the Bots in it.  Flows can be configured directly in YAML or via the Flow Composer GUI. This allows custom debug dashboards, crash reports, code review UIs and monitoring systems to be composed quickly and easily.  Below are several examples of different Flows.", 
            "title": "Your Systems, Your Way"
        }, 
        {
            "location": "/concepts/flows/#search-flow", 
            "text": "This Flow builds a simple search dashboard with three panels: a CLQL search field, a list of file and line matches and a graph.   In this example, the executed query is searching runtime and AST information about a CSharp repository stored in a GitHub repository. To answer the query, the CodeLingo Platform fires up three lexicons: the Git Lexicon retrieves the code from the GitHub repository, the AST lexicon queries the code and the Runtime lexicon builds and runs the code and queries its runtime information.", 
            "title": "Search Flow"
        }, 
        {
            "location": "/concepts/flows/#ide-search-flow", 
            "text": "Interacting with Flows is not restricted to the Flow Dashboard. Bots can recieve input and give output to other external services.   In this example a CodeLingo IDE plugin allows the user to query code within their IDE and navigate to the result, while also generating a graph of the results on the Flow Dashboard.", 
            "title": "IDE Search Flow"
        }, 
        {
            "location": "/concepts/flows/#review-flow", 
            "text": "This is an example of a fully automated flow with no dashboard. When a pull request is made to the monitored repository, GitHub sends a web hook to the Bot. That Bot then queries the pull request and repository for any Tenets.   The next Bot in the Flow then queries the pull request with the Tenets. Any issues found are added as comments on the pull request.", 
            "title": "Review Flow"
        }, 
        {
            "location": "/concepts/flows/#review-confirm-flow", 
            "text": "This is the same flow as above except a Bot waits for a human to confirm each found issue, via the dashboard, before commenting on the pull request.   Further customization of this Flow might include categorizing the issues and keeping track of which Tenets where kept and discarded.", 
            "title": "Review Confirm Flow"
        }, 
        {
            "location": "/concepts/flows/#crash-report-flow", 
            "text": "The crashed program has a single function added to it which sends the stack trace and any other data to the Bot in the Flow. The team is notified via Slack and a crash report is generated, ready to be analysed by a human.   Similar to the example above, this is a long running Flow which waits to be triggered by an external resource.", 
            "title": "Crash Report Flow"
        }, 
        {
            "location": "/concepts/flows/#crash-redeploy-flow", 
            "text": "This Flow extends the above crash report Flow to add in debugging, fixing and preventing. First the crash dump is sent, an issue is added on Jira and the team are alerted on Slack.  Along with the report panels, debug panels are added to help narrow down the cause of the crash and generate a Tenet to protect against future occurrences. The Lexicons reproduce a running state of the software, which matches, as close as possible, that of the crashed program with the information provided.", 
            "title": "Crash Redeploy Flow"
        }, 
        {
            "location": "/clql/", 
            "text": "CLQL\n\n\nA Query Language for Software Systems\n\n\nCodeLingo Query Language (CLQL) is a simple, lightweight language. It\u2019s full grammar is under \n70 lines of code\n.\n\n\n\n\nQuery Generation\n\n\nCodeLingo's Integrated Development Environment (IDE) plugins can help build patterns in code by automatically generating queries to detect selected elements of programs. A generated query will describe the selected element and its position in the structure of the program:\n\n\n\n\nIn the above example string literal is selected. The generated CLQL query will match any literal directly inside an assignment statement, in a function declaration, matching the nested pattern of the selected literal.\n\n\n\n\nFeatures\n\n\nQuerying with Facts\n\n\n\n\n\nCLQL can query many types of software related systems. But assume for simplicity that all queries in on this page are scoped to a single object oriented program.\n\n\n\n\n\nQueries are made up of \nFacts\n. A CLQL query with just a single fact will match all elements of that type in the program. The following query matches and returns all classes in the queried program:\n\n\n@ clair.comment\ncommon.class({depth: any})\n\n\n\n\nIt consists of a single fact \ncommon.class\n. The fact name \nclass\n indicates that the refers to a class, and the namespace \ncommon\n indicates that it may be a class from any language with classes. If the namespace were \ncsharp\n this fact would only match classes from the C# \nlexicon\n. The depth range \n{depth: any}\n makes this fact match any class within the context of the query (a single C# program), no matter how deeply nested.\nThe decorator \n@ clair.comment\n tells \nCLAIR\n (CodeLingo AI Reviewer) to make a comment on every class found.\n\n\nNote: for brevity we will omit the \ncommon\n namespace. This can be done in .lingo files by importing the common lexicon as an empty namespace: \nimport codelingo/ast/common/0.0.0 as _\n.\n\n\n\n\nFact Properties\n\n\nTo limit the above query to match classes with a particular name, add a \"name\" property as an argument to the \nmethod\n fact:\n\n\n@ clair.comment\nmethod({depth: any}):\n  name: \nmyFunc\n\n\n\n\n\nThis query returns all methods with the name \"myFunc\". Note that the yield tag is still on the \nmethod\n fact - properties cannot be returned, only their parent facts. Also note that properties are not namespaced, as their namespace is implied from their parent fact.\n\n\nFacts with arguments are proceeded by a colon.\n\n\n\n\nFloats and Ints\n\n\n\nProperties can be of type string, float, and int. The following finds all int literals with the value 8:\n\n\n@ clair.comment\nint_lit({depth: any}):\n  value: 5\n\n\n\n\nThis query finds float literals with the value 8.7:\n\n\n@ clair.comment\nfloat_lit({depth: any}):\n  value: 8.7\n\n\n\n\n\n\nComparison\n\n\nThe comparison operators \n, \n, ==, \n=, and \n= are available for floats and ints. The following finds all int literals above negative 3:\n\n\n@ clair.comment\nint_lit({depth: any}):\n  value: \n -3\n\n\n\n\n\n\nRegex\n\n\nAny string property can be queried with regex. The following finds methods with names longer than 25 characters:\n\n\n@ clair.comment\nmethod({depth: any}):\n  name: /^.{25,}$/\n\n\n\n\n\n\nFact Nesting\n\n\nFacts can be take arbitrarily many other facts as arguments, forming a query with a tree struct of arbitrary depth. A parent-child fact pair will match any parent element even if the child is not a direct descendant. The following query finds all the if statements inside a method called \"myMethod\", even those nested inside intermediate scopes (for loops etc):\n\n\nmethod({depth: any}):\n  name: \nmyMethod\n\n  @ clair.comment\n  if_stmt({depth: any})\n\n\n\n\nAny fact in a query can be yielded. If \nclass\n is yielded, this query returns all classes named \"myClass\", but only if it has at least one method:\n\n\nclass({depth: any}):\n  name: \u201cmyClass\u201d\n  @ clair.comment\n  method({depth: any})\n\n\n\n\nAny fact in a query can have properties. The following query finds all methods named \"myMethod\" on the all classes named \"myClass\":\n\n\nclass({depth: any}):\n  name: \u201cmyClass\u201d\n  @ clair.comment\n  method({depth: any}):\n    Name: \u201cmyMethod\u201d\n\n\n\n\nDepth\n\n\nFacts use depth ranges to specify the depth at which they can be found below their parent. Depth ranges have two zero based numbers, representing the minimum and maximum depth to find the result at, inclusive and exclusive respectively. The following query finds any if statements that are direct children of their parent method, in other words, if statements at depth zero from methods:\n\n\nmethod({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 0:1})\n\n\n\n\nThis query finds if statements at (zero based) depths 3, 4, and 5:\n\n\nmethod({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 3:6})\n\n\n\n\nA depth range where the maximum is not larger than the minimum, i.e., \n({depth: 5:5})\n or \n({depth: 6:0})\n, will give an error.\n\n\nDepth ranges specifying a single depth can be described with a single number. This query finds direct children at depth zero:\n\n\nmethod({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 0})\n\n\n\n\nIndicies in a depth range can range from 0 to positive infinity. Positive infinity is represented by leaving the second index empty. This query finds all methods, and all their descendant if_statements from depth 5 onwards:\n\n\nmethod({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 5:})\n\n\n\n\nThe depth range on top level facts, like \nmethod\n in the previous examples, determine the depth from the root to that fact. The root can be thought of as the node all other data hangs off. The values hanging off the root depend on the context of the query, it could be a \ngit.repo\n, \np4.repo\n, or \nproject\n for example. Example queries here use \n({depth: any})\n for top level facts to avoid context based ambiguity.\n\n\n\n\nBranching\n\n\nThe following query will find a method with a foreach loop, a for loop, and a while loop in that order:\n\n\n@ clair.comment\nmethod({depth: any}):\n  for_stmt\n  foreach_stmt\n  while_stmt\n\n\n\n\n\n\n\n\n\nNegation\n\n\nNegation allows queries to match children that \ndo not\n have a given property or child fact. Negated facts and properties are prepended by \"!\". The following query finds all classes except those named \"classA\":\n\n\n@ clair.comment\nclass({depth: any}):\n  !name: \nclassA\n\n\n\n\n\nThis query finds all classes with String methods:\n\n\n@ clair.comment\nclass({depth: any}):\n  !method:\n    name: \u201cString\u201d\n\n\n\n\nThe placement of the negation operator has a significant effect on the query's meaning - this similar query finds all methods with a method that is not called String:\n\n\n@ clair.comment\nclass({depth: any}):\n  method:\n    !name: \u201cString\u201d\n\n\n\n\nNegating a fact does not affect its siblings. The following query finds all String methods that use an if statement, but don\u2019t use a foreach statement:\n\n\n@ clair.comment\nmethod({depth: any}):\n  name: \u201cString\u201d\n  if_stmt\n  !foreach_stmt\n\n\n\n\nA fact cannot be both yielded and negated.\n\n\n\n\nOr\n\n\nA fact with multiple children will match against elements of the code that have child1 \nand\n child2 \nand\n child3 etc. The \u201cor\u201d operator overrides the implicit \"and\". The following query finds all String methods that use basic loops:\n\n\n@ clair.comment\nmethod({depth: any}):\n  name: \u201cString\u201d\n  or:\n    foreach_stmt\n    while_stmt\n    for_stmt\n\n\n\n\n\n\n\n\n\nVariables\n\n\nFacts that do not have a parent-child relationship can be compared by assigning their properties to variables. Any argument starting with \u201c$\u201d defines a variable. A query with a variable will only match a pattern in the code if all properties representing that variable are equal.\n\n\nThe following query compares two classes (which do have a parent-child relationship) and returns the methods which both classes implement:\n\n\nclass({depth: any}):\n  name: \u201cclassA\u201d\n  @ clair.comment\n  method:\n    name: $methodName\nclass({depth: any}):\n  name: \u201cclassB\u201d\n  method:\n    name: $methodName\n\n\n\n\nThe query above will only return methods of classA for which classB has a corresponding method.\n\n\n\n\nInterleaving\n\n\nWhen writing a Tenet in a .lingo file read by CLAIR, only the AST lexicon facts are required:\n\n\nlexicons:\n- vcs/codelingo/git\n- ast/codelingo/cs\n\ntenets:\n  - name: all-classes\n    match: \n      project:\n        @ clair.comment\n        class\n\n\n\n\nCLAIR adds the repository information to the query before searching the CodeLingo Platform:\n\n\nlexicons:\n- vcs/codelingo/git\n- ast/codelingo/cs\n\nquery:\n  git.repo:\n    name: \u201cyourRepo\u201d\n    owner: \u201cyou\u201d\n    host: \u201clocal\u201d\n    git.commit: \n      sha: \u201cHEAD\u201d    \n      project:\n        @ clair.comment\n        class\n\n\n\n\nEvery query to the CodeLingo platform itself starts with VCS facts to instruct the CodeLingo Platform on where to retrieve the source code from.\n\n\nGit (and indeed any Version Control System) facts can be used to query for changes in the code over time. For example, the following query checks if a given method has increased its number of arguments:\n\n\ngit.repo:\n  name: \u201cyourRepo\u201d\n  owner: \u201cyou\u201d\n  host: \u201clocal\u201d\n  git.commit: \n    sha: \u201cHEAD^\u201d\n    project:\n      method:\n        arg-num: $args\n  git.commit:\n    sha: \u201cHEAD\u201d    \n    project:\n      @ clair.comment\n      method:\n        arg-num: \n $args\n\n\n\n\nExamples\n\n\n\n\nCSharp\n\n\nIterative code, such as the following, can be more safely expressed declaratively using LINQ. For example: \n\n\ndecimal total = 0;\nforeach (Account account in myAccounts) {\n  if (account.Status == \nactive\n) {\n  total += account.Balance;\n  }\n}\n\n\n\n\ncan be expressed with:\n\n\ndecimal total = (from account in myAccounts\n          where account.Status == \nactive\n\n          select account.Balance).Sum();\n\n\n\n\nThe CLQL to match this pattern should find all variables that are declared before a foreach statement, and are incremented within the loop. The facts for incrementing inside a foreach loop, and declaring a variable can be generated in the IDE:\n\n\n\n\n\n\nThen the generated code can be turned into a working query by combining the above queries under the same file and scope, removing extraneous facts, and using a CLQL variable to ensure that the \ncs.variable\n facts are refering to the same variable:\n\n\ncs.file:\n  cs.block_stmt:\n    cs.assign_stmt:\n      cs.decl_stmt:\n        cs.variable:\n          name: $varName\n    @ clair.comment\n    cs.foreach_stmt:\n      cs.increment_by_expr:\n        cs.variable:\n          name: $varName\n\n\n\n\n\n\nC++\n\n\nThe following tenet asserts that functions should not return local objects by reference. When the function returns and the stack is unwrapped, that object will be destructed, and the reference will not point to anything.\n\n\nThe following query finds this bug by matching all functions that return a reference type, and declare the returned value inside the function body:\n\n\ncc.func_decl:\n  cc.func_header:\n    cc.return_type:\n      cc.reference\n  cc.block_stmt:\n    cc.declaration_stmt:\n      cc.variable:\n        name: $returnedReference\n    cc.return_stmt:\n      cc.variable:\n        name: $returnedReference", 
            "title": "CLQL"
        }, 
        {
            "location": "/clql/#clql", 
            "text": "", 
            "title": "CLQL"
        }, 
        {
            "location": "/clql/#a-query-language-for-software-systems", 
            "text": "CodeLingo Query Language (CLQL) is a simple, lightweight language. It\u2019s full grammar is under  70 lines of code .", 
            "title": "A Query Language for Software Systems"
        }, 
        {
            "location": "/clql/#query-generation", 
            "text": "CodeLingo's Integrated Development Environment (IDE) plugins can help build patterns in code by automatically generating queries to detect selected elements of programs. A generated query will describe the selected element and its position in the structure of the program:   In the above example string literal is selected. The generated CLQL query will match any literal directly inside an assignment statement, in a function declaration, matching the nested pattern of the selected literal.", 
            "title": "Query Generation"
        }, 
        {
            "location": "/clql/#features", 
            "text": "", 
            "title": "Features"
        }, 
        {
            "location": "/clql/#querying-with-facts", 
            "text": "CLQL can query many types of software related systems. But assume for simplicity that all queries in on this page are scoped to a single object oriented program.   Queries are made up of  Facts . A CLQL query with just a single fact will match all elements of that type in the program. The following query matches and returns all classes in the queried program:  @ clair.comment\ncommon.class({depth: any})  It consists of a single fact  common.class . The fact name  class  indicates that the refers to a class, and the namespace  common  indicates that it may be a class from any language with classes. If the namespace were  csharp  this fact would only match classes from the C#  lexicon . The depth range  {depth: any}  makes this fact match any class within the context of the query (a single C# program), no matter how deeply nested.\nThe decorator  @ clair.comment  tells  CLAIR  (CodeLingo AI Reviewer) to make a comment on every class found.  Note: for brevity we will omit the  common  namespace. This can be done in .lingo files by importing the common lexicon as an empty namespace:  import codelingo/ast/common/0.0.0 as _ .", 
            "title": "Querying with Facts"
        }, 
        {
            "location": "/clql/#fact-properties", 
            "text": "To limit the above query to match classes with a particular name, add a \"name\" property as an argument to the  method  fact:  @ clair.comment\nmethod({depth: any}):\n  name:  myFunc   This query returns all methods with the name \"myFunc\". Note that the yield tag is still on the  method  fact - properties cannot be returned, only their parent facts. Also note that properties are not namespaced, as their namespace is implied from their parent fact.  Facts with arguments are proceeded by a colon.", 
            "title": "Fact Properties"
        }, 
        {
            "location": "/clql/#floats-and-ints", 
            "text": "Properties can be of type string, float, and int. The following finds all int literals with the value 8:  @ clair.comment\nint_lit({depth: any}):\n  value: 5  This query finds float literals with the value 8.7:  @ clair.comment\nfloat_lit({depth: any}):\n  value: 8.7", 
            "title": "Floats and Ints"
        }, 
        {
            "location": "/clql/#comparison", 
            "text": "The comparison operators  ,  , ==,  =, and  = are available for floats and ints. The following finds all int literals above negative 3:  @ clair.comment\nint_lit({depth: any}):\n  value:   -3", 
            "title": "Comparison"
        }, 
        {
            "location": "/clql/#regex", 
            "text": "Any string property can be queried with regex. The following finds methods with names longer than 25 characters:  @ clair.comment\nmethod({depth: any}):\n  name: /^.{25,}$/", 
            "title": "Regex"
        }, 
        {
            "location": "/clql/#fact-nesting", 
            "text": "Facts can be take arbitrarily many other facts as arguments, forming a query with a tree struct of arbitrary depth. A parent-child fact pair will match any parent element even if the child is not a direct descendant. The following query finds all the if statements inside a method called \"myMethod\", even those nested inside intermediate scopes (for loops etc):  method({depth: any}):\n  name:  myMethod \n  @ clair.comment\n  if_stmt({depth: any})  Any fact in a query can be yielded. If  class  is yielded, this query returns all classes named \"myClass\", but only if it has at least one method:  class({depth: any}):\n  name: \u201cmyClass\u201d\n  @ clair.comment\n  method({depth: any})  Any fact in a query can have properties. The following query finds all methods named \"myMethod\" on the all classes named \"myClass\":  class({depth: any}):\n  name: \u201cmyClass\u201d\n  @ clair.comment\n  method({depth: any}):\n    Name: \u201cmyMethod\u201d", 
            "title": "Fact Nesting"
        }, 
        {
            "location": "/clql/#depth", 
            "text": "Facts use depth ranges to specify the depth at which they can be found below their parent. Depth ranges have two zero based numbers, representing the minimum and maximum depth to find the result at, inclusive and exclusive respectively. The following query finds any if statements that are direct children of their parent method, in other words, if statements at depth zero from methods:  method({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 0:1})  This query finds if statements at (zero based) depths 3, 4, and 5:  method({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 3:6})  A depth range where the maximum is not larger than the minimum, i.e.,  ({depth: 5:5})  or  ({depth: 6:0}) , will give an error.  Depth ranges specifying a single depth can be described with a single number. This query finds direct children at depth zero:  method({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 0})  Indicies in a depth range can range from 0 to positive infinity. Positive infinity is represented by leaving the second index empty. This query finds all methods, and all their descendant if_statements from depth 5 onwards:  method({depth: any}):\n  @ clair.comment\n  if_stmt({depth: 5:})  The depth range on top level facts, like  method  in the previous examples, determine the depth from the root to that fact. The root can be thought of as the node all other data hangs off. The values hanging off the root depend on the context of the query, it could be a  git.repo ,  p4.repo , or  project  for example. Example queries here use  ({depth: any})  for top level facts to avoid context based ambiguity.", 
            "title": "Depth"
        }, 
        {
            "location": "/clql/#branching", 
            "text": "The following query will find a method with a foreach loop, a for loop, and a while loop in that order:  @ clair.comment\nmethod({depth: any}):\n  for_stmt\n  foreach_stmt\n  while_stmt", 
            "title": "Branching"
        }, 
        {
            "location": "/clql/#negation", 
            "text": "Negation allows queries to match children that  do not  have a given property or child fact. Negated facts and properties are prepended by \"!\". The following query finds all classes except those named \"classA\":  @ clair.comment\nclass({depth: any}):\n  !name:  classA   This query finds all classes with String methods:  @ clair.comment\nclass({depth: any}):\n  !method:\n    name: \u201cString\u201d  The placement of the negation operator has a significant effect on the query's meaning - this similar query finds all methods with a method that is not called String:  @ clair.comment\nclass({depth: any}):\n  method:\n    !name: \u201cString\u201d  Negating a fact does not affect its siblings. The following query finds all String methods that use an if statement, but don\u2019t use a foreach statement:  @ clair.comment\nmethod({depth: any}):\n  name: \u201cString\u201d\n  if_stmt\n  !foreach_stmt  A fact cannot be both yielded and negated.", 
            "title": "Negation"
        }, 
        {
            "location": "/clql/#or", 
            "text": "A fact with multiple children will match against elements of the code that have child1  and  child2  and  child3 etc. The \u201cor\u201d operator overrides the implicit \"and\". The following query finds all String methods that use basic loops:  @ clair.comment\nmethod({depth: any}):\n  name: \u201cString\u201d\n  or:\n    foreach_stmt\n    while_stmt\n    for_stmt", 
            "title": "Or"
        }, 
        {
            "location": "/clql/#variables", 
            "text": "Facts that do not have a parent-child relationship can be compared by assigning their properties to variables. Any argument starting with \u201c$\u201d defines a variable. A query with a variable will only match a pattern in the code if all properties representing that variable are equal.  The following query compares two classes (which do have a parent-child relationship) and returns the methods which both classes implement:  class({depth: any}):\n  name: \u201cclassA\u201d\n  @ clair.comment\n  method:\n    name: $methodName\nclass({depth: any}):\n  name: \u201cclassB\u201d\n  method:\n    name: $methodName  The query above will only return methods of classA for which classB has a corresponding method.", 
            "title": "Variables"
        }, 
        {
            "location": "/clql/#interleaving", 
            "text": "When writing a Tenet in a .lingo file read by CLAIR, only the AST lexicon facts are required:  lexicons:\n- vcs/codelingo/git\n- ast/codelingo/cs\n\ntenets:\n  - name: all-classes\n    match: \n      project:\n        @ clair.comment\n        class  CLAIR adds the repository information to the query before searching the CodeLingo Platform:  lexicons:\n- vcs/codelingo/git\n- ast/codelingo/cs\n\nquery:\n  git.repo:\n    name: \u201cyourRepo\u201d\n    owner: \u201cyou\u201d\n    host: \u201clocal\u201d\n    git.commit: \n      sha: \u201cHEAD\u201d    \n      project:\n        @ clair.comment\n        class  Every query to the CodeLingo platform itself starts with VCS facts to instruct the CodeLingo Platform on where to retrieve the source code from.  Git (and indeed any Version Control System) facts can be used to query for changes in the code over time. For example, the following query checks if a given method has increased its number of arguments:  git.repo:\n  name: \u201cyourRepo\u201d\n  owner: \u201cyou\u201d\n  host: \u201clocal\u201d\n  git.commit: \n    sha: \u201cHEAD^\u201d\n    project:\n      method:\n        arg-num: $args\n  git.commit:\n    sha: \u201cHEAD\u201d    \n    project:\n      @ clair.comment\n      method:\n        arg-num:   $args", 
            "title": "Interleaving"
        }, 
        {
            "location": "/clql/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/clql/#csharp", 
            "text": "Iterative code, such as the following, can be more safely expressed declaratively using LINQ. For example:   decimal total = 0;\nforeach (Account account in myAccounts) {\n  if (account.Status ==  active ) {\n  total += account.Balance;\n  }\n}  can be expressed with:  decimal total = (from account in myAccounts\n          where account.Status ==  active \n          select account.Balance).Sum();  The CLQL to match this pattern should find all variables that are declared before a foreach statement, and are incremented within the loop. The facts for incrementing inside a foreach loop, and declaring a variable can be generated in the IDE:    Then the generated code can be turned into a working query by combining the above queries under the same file and scope, removing extraneous facts, and using a CLQL variable to ensure that the  cs.variable  facts are refering to the same variable:  cs.file:\n  cs.block_stmt:\n    cs.assign_stmt:\n      cs.decl_stmt:\n        cs.variable:\n          name: $varName\n    @ clair.comment\n    cs.foreach_stmt:\n      cs.increment_by_expr:\n        cs.variable:\n          name: $varName", 
            "title": "CSharp"
        }, 
        {
            "location": "/clql/#c", 
            "text": "The following tenet asserts that functions should not return local objects by reference. When the function returns and the stack is unwrapped, that object will be destructed, and the reference will not point to anything.  The following query finds this bug by matching all functions that return a reference type, and declare the returned value inside the function body:  cc.func_decl:\n  cc.func_header:\n    cc.return_type:\n      cc.reference\n  cc.block_stmt:\n    cc.declaration_stmt:\n      cc.variable:\n        name: $returnedReference\n    cc.return_stmt:\n      cc.variable:\n        name: $returnedReference", 
            "title": "C++"
        }, 
        {
            "location": "/use-cases/ast/", 
            "text": "Abstract Syntax Tree (AST)\n\n\nAbstract Syntax Tree (AST) \nlexicons\n are used to query static properties of source code. These are typically used to enforce project specific patterns such as layering violations as well as more general code smells.\n\n\nCLQL vs StyleCop\n\n\nCLQL, like StyleCop, can express C# style rules and use them to analyze a project, file, repository, or pull request. CLQL, like StyleCop can customize a set of predefined rules to determine how they should apply to a given project, and both can define custom rules.\n\n\nStyleCop supports custom rules by providing a SourceAnalyzer class with CodeWalker methods. The rule author can iterate through elements of the document and raise violations when the code matches a certain pattern. \n\n\nCLQL can express all rules that can be expressed in StyleCop. By abstracting away the details of document walking, CLQL can express in 9 lines, \na rule\n that takes ~50 lines of StyleCop. In addition to being, on average, 5 times less code to express these patterns, CLQL queries can be \ngenerated\n by selecting the code code elements in an IDE.\n\n\nCLQL is not limited to C# like StyleCop. CLQL can express logic about other domains of logic otuside of the scope of StyleCop, like version control.\n\n\nEmpty Block Statements\n\n\nStyleCop can use a custom rule to raise a violation for all empty block statements:\n\n\nnamespace Testing.EmptyBlockRule {\n    using global::StyleCop;\n    using global::styleCop.CSharp;\n\n    [SourceAnalyzer(typeof(CsParser))]\n    public class EmptyBlocks : SourceAnalyzer\n    {\n        public override void AnalyzeDocument(CodeDocument document)\n        {\n            CsDocument csdocument = (CsDocument)document;\n            if (csdocument.RootElement != null \namp;\namp; !csdocument.RootElement.Generated)\n            {\n                csdocument.WalkDocument(\n                    new CodeWalkerElementVisitor\nlt;object\ngt;(this.VisitElement),\n                    null,\n                    null);\n            }\n        }\n\n        private bool VisitElement(CsElement element, CsElement parentElement, object context)\n        {\n            if (statement.StatementType == StatementType.Block \n statement.ChildStatements.Count == 0)\n            {\n                this.AddViolation(parentElement, statement.LineNumber, \nBlockStatementsShouldNotBeEmpty\n);\n            }\n        }\n\n\n        private bool VisitStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context)\n        {\n            if (statement.StatementType == StatementType.Block \n statement.ChildStatements.Count == 0)\n            {\n                this.AddViolation(parentElement, statement.LineNumber, \nBlockStatementsShouldNotBeEmpty\n);\n            }\n        }\n    }\n}\n\n\n\n\nSourceAnalyzer Name=\nEmptyBlocks\n\n  \nDescription\n\n    Code blocks should not be empty.\n  \n/Description\n\n  \nRules\n\n    \nRuleGroup Name=\nFun Rules You Will Love\n\n      \nRule Name=\nBlockStatementsShouldNotBeEmpty\n CheckId=\nMY1000\n\n        \nContext\nA block statement should always contain child statements.\n/Context\n\n        \nDescription\nValidates that the code does not contain any empty block statements.\n/Description\n\n      \n/Rule\n\n    \n/RuleGroup\n\n  \n/Rules\n\n\n/SourceAnalyzer\n\n\n\n\n\nThe same rule can be expressed in CLQL as the following \ntenet\n:\n\n\nlexicons: \n  - ast/codelingo/csharp as cs\ntenets:\n  - Name: \nEmptyBlock\n\n    Comment: \nA block statement should always contain child statements.\n\n    Doc: \nValidates that the code does not contain any empty block statements.\n\n    Match: \n      cs.block_stmt:\n        !cs.element\n\n\n\n\nThe VisitStatement function contains the core logic of this StyleCop rule:\n\n\nprivate bool VisitStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context)\n{\n    if (statement.StatementType == StatementType.Block \n statement.ChildStatements.Count == 0)\n    {\n        this.AddViolation(parentElement, statement.LineNumber, \nBlockStatementsShouldNotBeEmpty\n);\n    }\n}\n\n\n\n\nThe VisitStatement method is run at every node of the AST tree, then a violation is added if the node is a block statement with no children.\nIn CLQL, the match statement expresses the logic of the query. Traversal is entirely abstracted away, and the tenet author only needs to express the condition for a \"rule violation\":\n\n\ncs.block_stmt:\n  !cs.element\n\n\n\n\nThe above query will match against any block statement that does not contain anything at all. \ncs.element\n \nmatches all\n C# elements, and the \"!\" operator performs \nnegation\n. \n\n\nAccess Modifier Declaration\n\n\nIn this example, we'll exclude StyleCop's long setup and document traversal boilerplace and focus on the query, which raises a violation for all non-generated code that doesn't have a declared access modifier:\n\n\nprivate bool VisitElement(CsElement element, CsElement parentElement, object context)\n{\n    // Make sure this element is not generated.\n    if (!element.Generated)\n    {\n        // Flag a violation if the element does not have an access modifier.\n        if (!element.Declaration.AccessModifier)\n        {\n            this.AddViolation(element, \nAccessModifiersMustBeDeclared\n);\n        }\n    }\n}\n\n\n\n\nAs in the \nempty block statements\n example, to express the pattern in CLQL, the tenet author only needs to express conditions in the VisitElement body:\n\n\ncs.element:\n  generated: \nfalse\n\n  cs.declaration_stmt:\n    cs.access_modifier: \nfalse\n\n\n\n\n\nThe above query matches all C# elements that are not generated, whose declaration does not have an access modifier.", 
            "title": "AST"
        }, 
        {
            "location": "/use-cases/ast/#abstract-syntax-tree-ast", 
            "text": "Abstract Syntax Tree (AST)  lexicons  are used to query static properties of source code. These are typically used to enforce project specific patterns such as layering violations as well as more general code smells.", 
            "title": "Abstract Syntax Tree (AST)"
        }, 
        {
            "location": "/use-cases/ast/#clql-vs-stylecop", 
            "text": "CLQL, like StyleCop, can express C# style rules and use them to analyze a project, file, repository, or pull request. CLQL, like StyleCop can customize a set of predefined rules to determine how they should apply to a given project, and both can define custom rules.  StyleCop supports custom rules by providing a SourceAnalyzer class with CodeWalker methods. The rule author can iterate through elements of the document and raise violations when the code matches a certain pattern.   CLQL can express all rules that can be expressed in StyleCop. By abstracting away the details of document walking, CLQL can express in 9 lines,  a rule  that takes ~50 lines of StyleCop. In addition to being, on average, 5 times less code to express these patterns, CLQL queries can be  generated  by selecting the code code elements in an IDE.  CLQL is not limited to C# like StyleCop. CLQL can express logic about other domains of logic otuside of the scope of StyleCop, like version control.", 
            "title": "CLQL vs StyleCop"
        }, 
        {
            "location": "/use-cases/ast/#empty-block-statements", 
            "text": "StyleCop can use a custom rule to raise a violation for all empty block statements:  namespace Testing.EmptyBlockRule {\n    using global::StyleCop;\n    using global::styleCop.CSharp;\n\n    [SourceAnalyzer(typeof(CsParser))]\n    public class EmptyBlocks : SourceAnalyzer\n    {\n        public override void AnalyzeDocument(CodeDocument document)\n        {\n            CsDocument csdocument = (CsDocument)document;\n            if (csdocument.RootElement != null  amp; amp; !csdocument.RootElement.Generated)\n            {\n                csdocument.WalkDocument(\n                    new CodeWalkerElementVisitor lt;object gt;(this.VisitElement),\n                    null,\n                    null);\n            }\n        }\n\n        private bool VisitElement(CsElement element, CsElement parentElement, object context)\n        {\n            if (statement.StatementType == StatementType.Block   statement.ChildStatements.Count == 0)\n            {\n                this.AddViolation(parentElement, statement.LineNumber,  BlockStatementsShouldNotBeEmpty );\n            }\n        }\n\n\n        private bool VisitStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context)\n        {\n            if (statement.StatementType == StatementType.Block   statement.ChildStatements.Count == 0)\n            {\n                this.AddViolation(parentElement, statement.LineNumber,  BlockStatementsShouldNotBeEmpty );\n            }\n        }\n    }\n}  SourceAnalyzer Name= EmptyBlocks \n   Description \n    Code blocks should not be empty.\n   /Description \n   Rules \n     RuleGroup Name= Fun Rules You Will Love \n       Rule Name= BlockStatementsShouldNotBeEmpty  CheckId= MY1000 \n         Context A block statement should always contain child statements. /Context \n         Description Validates that the code does not contain any empty block statements. /Description \n       /Rule \n     /RuleGroup \n   /Rules  /SourceAnalyzer   The same rule can be expressed in CLQL as the following  tenet :  lexicons: \n  - ast/codelingo/csharp as cs\ntenets:\n  - Name:  EmptyBlock \n    Comment:  A block statement should always contain child statements. \n    Doc:  Validates that the code does not contain any empty block statements. \n    Match: \n      cs.block_stmt:\n        !cs.element  The VisitStatement function contains the core logic of this StyleCop rule:  private bool VisitStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context)\n{\n    if (statement.StatementType == StatementType.Block   statement.ChildStatements.Count == 0)\n    {\n        this.AddViolation(parentElement, statement.LineNumber,  BlockStatementsShouldNotBeEmpty );\n    }\n}  The VisitStatement method is run at every node of the AST tree, then a violation is added if the node is a block statement with no children.\nIn CLQL, the match statement expresses the logic of the query. Traversal is entirely abstracted away, and the tenet author only needs to express the condition for a \"rule violation\":  cs.block_stmt:\n  !cs.element  The above query will match against any block statement that does not contain anything at all.  cs.element   matches all  C# elements, and the \"!\" operator performs  negation .", 
            "title": "Empty Block Statements"
        }, 
        {
            "location": "/use-cases/ast/#access-modifier-declaration", 
            "text": "In this example, we'll exclude StyleCop's long setup and document traversal boilerplace and focus on the query, which raises a violation for all non-generated code that doesn't have a declared access modifier:  private bool VisitElement(CsElement element, CsElement parentElement, object context)\n{\n    // Make sure this element is not generated.\n    if (!element.Generated)\n    {\n        // Flag a violation if the element does not have an access modifier.\n        if (!element.Declaration.AccessModifier)\n        {\n            this.AddViolation(element,  AccessModifiersMustBeDeclared );\n        }\n    }\n}  As in the  empty block statements  example, to express the pattern in CLQL, the tenet author only needs to express conditions in the VisitElement body:  cs.element:\n  generated:  false \n  cs.declaration_stmt:\n    cs.access_modifier:  false   The above query matches all C# elements that are not generated, whose declaration does not have an access modifier.", 
            "title": "Access Modifier Declaration"
        }, 
        {
            "location": "/use-cases/vcs/", 
            "text": "VCS\n\n\nWith Version Control System (VCS) lexicons, facts about the VCS itself can be queried: commit comments, commit SHAs, authorship and other metadata.", 
            "title": "VCS"
        }, 
        {
            "location": "/use-cases/vcs/#vcs", 
            "text": "With Version Control System (VCS) lexicons, facts about the VCS itself can be queried: commit comments, commit SHAs, authorship and other metadata.", 
            "title": "VCS"
        }, 
        {
            "location": "/use-cases/runtime/", 
            "text": "Runtime\n\n\nRuntime lexicons are used to query the runtime data of a program. These are typically used to identify performance issues and common runtime problems.\n\n\nDetecting Memory Leaks\n\n\nIn the example below we have a database manager class that wraps up a third party library we use to return connections to a database.\n\n\nFrom past profiles of our application, we expect the function \ngetDBCon\n to use less than 10MB of memory. If it uses more than this, we want to be notified.\n\n\nWe can do this with the following Tenet:\n\n\ncsprof.session:\n  csprof.exec:\n      command: \n./scripts/build.sh\n\n      args: \n-o ./bin/program.exe\n\n  csprof.exec:\n    command: \n./bin/program.exe\n\n    args: \n/host:127.0.0.1 /db:testing\n\n  cs.file:\n    filename: \n./db/manager.cs\n\n    @ clair.comment\n    cs.method:\n      name: \ngetDBCon\n\n      csprof.exit:\n        memory_mb: \n= 10\n\n\n\n\nSometime in the future we decide to update the underlying library to the latest version. After profiling our application again, CodeLingo catches that multiple instances of the \ngetDBCon\n function have exceeded the \n= 10MB memory\n Tenet.\n\n\nAs we iterate over the issues, we see a steady increase in the memory consumed by the \ngetDBCon\n function. Knowing that this didn't happen with the older version of the library, we suspect a memory leak may have been introduced in the update and further investigation is required.\n\n\nNote: CLQL is able to assist in pin-pointing the source of memory leaks, but that is outside the scope of this use case.\n\n\n\n\nDetecting Race Conditions\n\n\nIn the example below we have a database manager class that we use to update and read user records.\n\n\nOur application has a number of different workers that operate asynchronously, making calls to the database manager at any time.\n\n\nWe need to know if our database manager is handling the asynchronous calls correctly, so we write a tenet below to catch potential race conditions between two functions used by the workers:\n\n\ncsprof.session:\n  csprof.exec:\n    command: \n./scripts/build.sh\n\n    args: \n-o ./bin/program.exe\n\n  csprof.exec:\n    command: \n./bin/program.exe\n\n    args: \n/host:127.0.0.1 /db:testing\n\n  cs.file:\n    filename: \n./db/manager.cs\n\n    cs.method:\n      name: \nupdateUser\n\n      csprof.block_start:\n        time: $startUpdate\n      csprof.block_exit:\n        time: $exitUpdate\n    @ clair.comment\n    cs.method:\n      name: \ngetUser\n\n      csprof.block_start:\n        time: \n $startUpdate\n      csprof.block_start:\n        time: \n $exitUpdate\n\n\n\n\nThis query users \nvariables\n If the \ngetUser\n function is called while an instance of the \nupdateUser\n function is in progress, the \ngetUser\n function must return after the \nupdateUser\n function to prevent a dirty read from the database. An issue will be raised if this does not hold true.\n\n\n\n\nDetecting Deadlocks\n\n\nIn the example below, we have an application used for importing data into a database from a number of different sources asynchronously. The \nimportData\n function is particularly resource heavy on our server due to the raw amount of data that needs to be processed. Knowing this, we decide to write a Tenet to catch any idle instances of the \nimportData\n function:\n\n\ncs.session:\n  csprof.exec:\n    command: \n./scripts/build.sh\n\n    args: \n-o ./bin/program.exe\n\n  csprof.exec:\n    command: \n./bin/program.exe\n\n    args: \n/host:127.0.0.1 /db:testing\n\n  cs.file:\n    filename: \n./db/manager.cs\n\n    @ clair.comment\n    cs.method:\n      name: \nimportData\n\n      csprof.duration:\n        time_min: \n= 4\n        average_cpu_percent: \n= 1\n        average_memory_mb: \n= 10\n\n\n\n\nIf an instance of the \nimportData\n runs for more than 4 minutes with unusually low resource usage, an issue will be raised as the function is suspect of deadlock.", 
            "title": "Runtime"
        }, 
        {
            "location": "/use-cases/runtime/#runtime", 
            "text": "Runtime lexicons are used to query the runtime data of a program. These are typically used to identify performance issues and common runtime problems.", 
            "title": "Runtime"
        }, 
        {
            "location": "/use-cases/runtime/#detecting-memory-leaks", 
            "text": "In the example below we have a database manager class that wraps up a third party library we use to return connections to a database.  From past profiles of our application, we expect the function  getDBCon  to use less than 10MB of memory. If it uses more than this, we want to be notified.  We can do this with the following Tenet:  csprof.session:\n  csprof.exec:\n      command:  ./scripts/build.sh \n      args:  -o ./bin/program.exe \n  csprof.exec:\n    command:  ./bin/program.exe \n    args:  /host:127.0.0.1 /db:testing \n  cs.file:\n    filename:  ./db/manager.cs \n    @ clair.comment\n    cs.method:\n      name:  getDBCon \n      csprof.exit:\n        memory_mb:  = 10  Sometime in the future we decide to update the underlying library to the latest version. After profiling our application again, CodeLingo catches that multiple instances of the  getDBCon  function have exceeded the  = 10MB memory  Tenet.  As we iterate over the issues, we see a steady increase in the memory consumed by the  getDBCon  function. Knowing that this didn't happen with the older version of the library, we suspect a memory leak may have been introduced in the update and further investigation is required.  Note: CLQL is able to assist in pin-pointing the source of memory leaks, but that is outside the scope of this use case.", 
            "title": "Detecting Memory Leaks"
        }, 
        {
            "location": "/use-cases/runtime/#detecting-race-conditions", 
            "text": "In the example below we have a database manager class that we use to update and read user records.  Our application has a number of different workers that operate asynchronously, making calls to the database manager at any time.  We need to know if our database manager is handling the asynchronous calls correctly, so we write a tenet below to catch potential race conditions between two functions used by the workers:  csprof.session:\n  csprof.exec:\n    command:  ./scripts/build.sh \n    args:  -o ./bin/program.exe \n  csprof.exec:\n    command:  ./bin/program.exe \n    args:  /host:127.0.0.1 /db:testing \n  cs.file:\n    filename:  ./db/manager.cs \n    cs.method:\n      name:  updateUser \n      csprof.block_start:\n        time: $startUpdate\n      csprof.block_exit:\n        time: $exitUpdate\n    @ clair.comment\n    cs.method:\n      name:  getUser \n      csprof.block_start:\n        time:   $startUpdate\n      csprof.block_start:\n        time:   $exitUpdate  This query users  variables  If the  getUser  function is called while an instance of the  updateUser  function is in progress, the  getUser  function must return after the  updateUser  function to prevent a dirty read from the database. An issue will be raised if this does not hold true.", 
            "title": "Detecting Race Conditions"
        }, 
        {
            "location": "/use-cases/runtime/#detecting-deadlocks", 
            "text": "In the example below, we have an application used for importing data into a database from a number of different sources asynchronously. The  importData  function is particularly resource heavy on our server due to the raw amount of data that needs to be processed. Knowing this, we decide to write a Tenet to catch any idle instances of the  importData  function:  cs.session:\n  csprof.exec:\n    command:  ./scripts/build.sh \n    args:  -o ./bin/program.exe \n  csprof.exec:\n    command:  ./bin/program.exe \n    args:  /host:127.0.0.1 /db:testing \n  cs.file:\n    filename:  ./db/manager.cs \n    @ clair.comment\n    cs.method:\n      name:  importData \n      csprof.duration:\n        time_min:  = 4\n        average_cpu_percent:  = 1\n        average_memory_mb:  = 10  If an instance of the  importData  runs for more than 4 minutes with unusually low resource usage, an issue will be raised as the function is suspect of deadlock.", 
            "title": "Detecting Deadlocks"
        }, 
        {
            "location": "/use-cases/integration/", 
            "text": "Integration\n\n\n[documentation to come]", 
            "title": "Integration"
        }, 
        {
            "location": "/use-cases/integration/#integration", 
            "text": "[documentation to come]", 
            "title": "Integration"
        }
    ]
}