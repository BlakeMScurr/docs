# Flows
Flows automate common developer and sysadmin tasks by chaining together a pipeline of Bots. Each Flow has its own dashboard with panels generated by the Bots in it.

Flows can be configured directly in YAML or via the Flow Composer GUI. This allows custom debug dashboards, crash reports, code review UIs and monitoring systems to be composed quickly and easily.

Below are several examples of different Flows.


## Bots
Bots watch resources and look for patterns in them based on the [Tenets](/concepts/tenets.md) associated with the resource. For example, CodeLingo AI Reviewer (CLAIR) is a Bot that performs a review on a pull request:

<img src="/img/clair_review_simple.png" alt="CLAIR (CodeLingo AI Reviewer) commenting on a pull-request" style="width: 80%;"/>

CLAIR reads the Tenets written in .lingo files in the repository and queries the platform with them. She can be called directly via the command line:

```bash
$ lingo bot clair review --github-pull-request "https://github.com/example/prog/pull/272"
```


This will print out any patterns in the pull request that match those in the Tenets. In addition to being run directly, Bots can be added to a Flow. When part of a [Flow](/concepts/flows.md), Bots process the results and pass them onto an external service or other bots in the Flow.

Other possible Bots include:
 
- A forensic Bot that analyses logs and finds event B happened before A, which violates a Tenet
- A project overview Bot that graphs Tech Debt burndown chart and delegates based on ownership
- A Copilot Bot that gives real time feedback to a developer in their IDE as theyâ€™re coding
- A profiling Bot that detects high memory usage correlated to similar code
- A crash report Bot that monitors a running system and reports on unexpected runtime information


## Examples


### Search Flow

This Flow builds a simple search dashboard with three panels: a CLQL search field, a list of file and line matches and a graph.

<img src="/img/search_flow.jpg" style="width: 100%;"/>

In this example, the executed query is searching runtime and AST information about a CSharp repository stored in a GitHub repository. To answer the query, the CodeLingo Platform fires up three lexicons: the Git Lexicon retrieves the code from the GitHub repository, the AST lexicon queries the code and the Runtime lexicon builds and runs the code and queries its runtime information.

### IDE Search Flow

Interacting with Flows is not restricted to the Flow Dashboard. Bots can receive input and give output to other external services.

<img src="/img/ide_search_flow.jpg" style="width: 100%;"/>

In this example a CodeLingo IDE plugin allows the user to query code within their IDE and navigate to the result, while also generating a graph of the results on the Flow Dashboard.


### Review Flow

This is an example of a fully automated flow with no dashboard. When a pull request is made to the monitored repository, GitHub sends a webhook to the Bot. That Bot then queries the pull request and repository for any Tenets.

<img src="/img/review_flow.jpg" style="width: 100%;"/>

The next Bot in the Flow then queries the pull request with the Tenets. Any issues found are added as comments on the pull request.


### Review Confirm Flow

This is the same flow as above except a Bot waits for a human to confirm each found issue, via the dashboard, before commenting on the pull request.

<img src="/img/review_confirm_flow.jpg" style="width: 100%;"/>

Further customization of this Flow might include categorizing the issues and keeping track of which Tenets where kept and discarded.


### Crash Report Flow

The crashed program has a single function added to it which sends the stack trace and any other data to the Bot in the Flow. The team is notified via Slack and a crash report is generated, ready to be analysed by a human.

<img src="/img/crash_report_flow.jpg" style="width: 100%;"/>

Similar to the example above, this is a long running Flow which waits to be triggered by an external resource.

### Crash Redeploy Flow

This Flow extends the above crash report Flow to add in debugging, fixing and preventing. First the crash dump is sent, an issue is added on Jira and the team are alerted on Slack.

Along with the report panels, debug panels are added to help narrow down the cause of the crash and generate a Tenet to protect against future occurrences. The Lexicons reproduce a running state of the software, which matches, as close as possible, that of the crashed program with the information provided.


<img src="/img/crash_redeploy_flow.jpg" style="width: 100%;"/>


<!-- 
Note that the developer did not have to anything outside of their direct debug workflow and yet the issue was logged and marked as resolved. -->


